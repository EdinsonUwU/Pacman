La funcion onKey LITERALMENTE da el nuevo estado del mundo a a algun evento del teclado, por lo cual, si no se pone un nuevo estado del mundo,
para la proxima iteracion, ese objeto que no se puso desaparecerá.Por ejemplo:

processing.onKeyEvent = function (world, keyCode) {
      console.log(keyCode);
      switch (keyCode) {
        case processing.LEFT:
          return make(world, { pacman: { x: world.pacman.x, y: world.pacman.y, dirx: world.pacman.dirx = -3 } });
          break;
        case processing.RIGHT:
          return make(world, { pacman: { x: world.pacman.x, y: world.pacman.y, dirx: world.pacman.dirx = +3 } });
          break;
        default:
          console.log(keyCode);
          return make(world, {});
      }
    }
La razón de poner la todos los elementos de pacman es que si se preciona la tecla 1 (RIGHT) es que el mundo tendra esos valores,
Ahora bien, si se pone:

processing.onKeyEvent = function (world, keyCode) {
      console.log(keyCode);
      switch (keyCode) {
        case processing.LEFT:
          return make(world, { pacman: {dirx: world.pacman.dirx = -3 } });
          break;
        case processing.RIGHT:
          return make(world, { pacman: {dirx: world.pacman.dirx = +3 } });
          break;
        default:
          console.log(keyCode);
          return make(world, {});
      }
    }
    
    El nuevo mundo no tendrá ni la posicion en x ( x: world.pacman.x) ni la posicion en y (y: world.pacman.y,), por lo cual el pacman no
    sera pintado.
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
