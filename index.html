<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pacman</title>
    <script src="js/jquery-3.1.1.min.js"></script>
    <script src="js/processing.js"></script>
</head>

<div id="pagina">
    <canvas id="canvas"></canvas>
</div>

<style>
    #pagina {
        display: flex;
        width: 100%;
        justify-content: center;
        height: 100%;
        align-items: center;
    }

    #canvas {
        border-width: 5px;
        border-style: solid;
        border-color: black;
        border-radius: 10px;
    }

    body {
        background: #B22626;
    }
</style>


<script>
    //Vamos a usar http://processingjs.org/
    // o https://p5js.org/reference/

    /**
    * Ejemplo de interacción de la aplicación con el teclado. Se reacciona a las teclas de las flechas. 
    * Las teclas modifican la posición del rectángulo 
    */
    function sketchProc(processing) {
        // esto se llama antes de iniciar el juego
        processing.setup = function () {
            processing.frameRate(48);
            processing.size(mapa.size.width, mapa.size.height);
            processing.background(178, 38, 38);
            processing.state = { time: 1, pacman: { x: 150, y: 150, currentMovement: processing.RIGHT } };
        }

        // dibuja algo en el canvas. Aqui se pone todo lo que quieras pintar
        processing.drawGame = function (world) {
            // hace que no se muestre todos los lugares por donde ha estado pacman
            processing.background();
            dibujarMapa(world);
            //dibujarPacmanAnimado(world);

        }

        // Esta es la función que pinta todo. Se ejecuta 60 veces por segundo. 
        // No cambie esta función. Su código debe ir en drawGame
        processing.draw = function () {
            processing.drawGame(processing.state);
            processing.state = processing.onTic(processing.state);
        };

        // actualiza el mundo en cada tic del reloj. Retorna el nuevo stado del mundo
        processing.onTic = function (world) {
            return Object.assign(world, { time: world.time + 1 }, { pacman: moverPacman(world.pacman, world.time) });
        }

        // actualiza el mundo cada vez que se oprime una tecla. Retorna el nuevo stado del mundo
        processing.onKeyEvent = function (world, keyCode) {
            switch (keyCode) {
                case processing.UP:
                    return Object.assign(world, { pacman: { x: world.pacman.x, y: world.pacman.y, currentMovement: processing.UP } });
                    //x: world.pacman.x, y: world.pacman.y -5, 
                    break;
                case processing.DOWN:
                    return Object.assign(world, { pacman: { x: world.pacman.x, y: world.pacman.y, currentMovement: processing.DOWN } });
                    //x: world.pacman.x, y: world.pacman.y +5 , 
                    break;
                case processing.LEFT:
                    return Object.assign(world, { pacman: { x: world.pacman.x, y: world.pacman.y, currentMovement: processing.LEFT } });
                    //x: world.pacman.x -5, y: world.pacman.y,
                    break;
                case processing.RIGHT:
                    return Object.assign(world, { pacman: { x: world.pacman.x, y: world.pacman.y, currentMovement: processing.RIGHT } });
                    //x: world.pacman.x +5, y: world.pacman.y, 
                    break;
                default:
                    console.log(keyCode);
                    return Object.assign(world, {});
            }
        }

        // Esta función se ejecuta cada vez que presionamos una tecla.
        processing.keyPressed = function () {
            processing.state = processing.onKeyEvent(processing.state, processing.keyCode);
        }

        // ----------------------------------------------------------------------------------------------------------------
        // NUESTROS CODIGOS
        // ----------------------------------------------------------------------------------------------------------------
        function dibujarPacmanAnimado(world) {

            // dibuja el pacman en el mapa, se incluye la rotacion de acuerdo a la direccion de movimiento
            let pacman = world.pacman;
            if (pacman.currentMovement == processing.UP) {
                if ((world.time / 8) % 2 < 1) {
                    processing.arc(pacman.x, pacman.y, 50, 50, 0, Math.PI * 2)
                } else {
                    processing.arc(pacman.x, pacman.y, 50, 50, -Math.PI / 4.4, Math.PI * 1.2)
                }
            }
            if (pacman.currentMovement == processing.DOWN) {
                if ((world.time / 8) % 2 < 1) {
                    processing.arc(pacman.x, pacman.y, 50, 50, 0, Math.PI * 2)
                } else {
                    processing.arc(pacman.x, pacman.y, 50, 50, -Math.PI * 1.2, Math.PI / 5)
                }
            }
            if (pacman.currentMovement == processing.LEFT) {
                if ((world.time / 8) % 2 < 1) {
                    processing.arc(pacman.x, pacman.y, 50, 50, 0, Math.PI * 2)
                } else {
                    processing.arc(pacman.x, pacman.y, 50, 50, -Math.PI / 1.4, Math.PI * 0.75)
                }
            }
            if (pacman.currentMovement == processing.RIGHT) {
                if ((world.time / 8) % 2 < 1) {
                    processing.arc(pacman.x, pacman.y, 50, 50, 0, Math.PI * 2);
                } else {
                    processing.arc(pacman.x, pacman.y, 50, 50, Math.PI / 4, Math.PI * 1.7);
                }
            }

        }
        function dibujarMapa(world) {
            let cellSizeWidth = cellSize(mapa.size.width, mapa.matrix[0].length);
            let cellSizeHeight = cellSize(mapa.size.height, mapa.matrix.length);

            forEach(mapa.matrix, (row, i) => {
                forEach(row, (cell, j) => {
                    if (cell == mapa.pared) {
                        processing.fill(10, 30, 220); // color
                        processing.rect(j * cellSizeWidth, i * cellSizeHeight, cellSizeWidth, cellSizeHeight);
                    }
                    if (cell == mapa.camino) {
                        processing.fill(20, 35, 80); // color
                        processing.rect(j * cellSizeWidth, i * cellSizeHeight, cellSizeWidth, cellSizeHeight);
                    }
                })
            });
        }

        function cellSize(canvasSize, matrixSize) {
            return canvasSize / matrixSize;
        }
        /*
            mapa = {
                size:null,
                matrix:null,
                pared:null,
                camino:null
            }
        */
        const mapa = {
            size: {
                width: 889,
                height: 550
            },
            matrix: [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ],
            pared: 1,
            camino: 0
        };

        // cambia la longitud de los pasos de pacman
        const pacmanStep = 1;

        // cambia la posicion del pacman
        // proccessing.up sirve es la direccion
        // la funcion se llama asi: moverPacman(world.pacman, world.time)
        /*
        pacman = {
          x:null,
          y:null,
          currentMovement:null,
          nextMove:null
        }
        */
        // retorna un objeto del tipo pacman
        function moverPacman(pacman, gameTime) {

            // si pacman llego a la frontera, que se detenga
            if (pacman.x > mapa.size.width) {

            }
            if (pacman.x < 0) {

            }
            if (pacman.y > mapa.size.height) {

            }
            if (pacman.y <= 30 && pacman.currentMovement == processing.UP) {
                return { x: pacman.x, y: pacman.y, currentMovement: pacman.currentMovement };
            }

            // mover el pacman un step
            if (pacman.currentMovement == processing.UP)
                return { x: pacman.x, y: pacman.y - pacmanStep, currentMovement: pacman.currentMovement };

            if (pacman.currentMovement == processing.LEFT)
                return { x: pacman.x - pacmanStep, y: pacman.y, currentMovement: pacman.currentMovement };

            if (pacman.currentMovement == processing.DOWN)
                return { x: pacman.x, y: pacman.y + pacmanStep, currentMovement: pacman.currentMovement };

            if (pacman.currentMovement == processing.RIGHT)
                return { x: pacman.x + pacmanStep, y: pacman.y, currentMovement: pacman.currentMovement };
        }


        // ----------------------------------------------------------------------------------------------------------------
        // FIN NUESTROS CODIGOS
        // ----------------------------------------------------------------------------------------------------------------

        function forEach(l, f, index = 0) {
            if (!isEmpty(l)) {
                f(first(l), index);
                forEach(rest(l), f, index + 1);
            }
        }

        function isEmpty(list) {
            if (typeof list == 'object') {
                return list.length === 0;
            }
            return false;
        }

        function first(list) {
            return list.slice(0, 1)[0];
        }

        function rest(list) {
            return list.slice(1);
        }


        // ----------------------------------------------------------------------------------------------------------------
    }

    var canvas = document.getElementById("canvas");

    // Adjuntamos nuestro sketch al framework de processing
    var processingInstance = new Processing(canvas, sketchProc);

</script>